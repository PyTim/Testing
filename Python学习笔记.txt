Python学习笔记
	一. 输入输出
		1. print输出
			>>> print "hello world"
			hello world
			>>> print 'hello world'
			hello world
			>>> print 'Hello','world'
			Hello world
			>>> print "I'm studing python"
			I'm studing python
			>>> print 'I am studing "python"'
			I am studing "python"
			>>> print "I'm studing \"python\""
			I'm studing "python"
			>>> print 'I\'m studing "python"'
			I'm studing "python"
			>>> print '''I'm studing "python"'''
			I'm studing "python"
			>>> print '''I am
			... studing
			... "python"'''
			I am
			studing
			"python"
			
			>>> print "Name:%s Age:%d Height:%f" %('Tester',18,1.80)
			Name:Tester Age:18 Height:1.800000
			>>> print "Name:%8s Age:%3d Height:%5.2f" %('Tester',18,1.80)
			Name:  Tester Age: 18 Height: 1.80
			>>> print "Name:%-8s Age:%-3d Height:%-5.2f" %('Tester',18,1.80)
			Name:Tester   Age:18  Height:1.80 
			>>> print "Name:%s Age:%3d Height:%*.*f" % ('Tester',18,6,2,1.80)
			Name:Tester Age: 18 Height:  1.80
			print "Name:%r Age:%r Height:%r" %('Tester',18,1.80)
			Name:'Tester' Age:18 Height:1.8

			>>> print '12',3
			12 3
			>>> print '12'+3
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			TypeError: cannot concatenate 'str' and 'int' objects
			>>> print '12'+'3'
			123
			>>> print 12+3
			15
			>>> 
			
		总结：
			1) print 输出字符串可以使用''或者""表示；
			2) print后可以有多个输出，以逗号分隔，最终逗号以空格输出，两边类型可以不一致；
				也可以用+号连接，但是+号要求两边类型必须一致，连接数字表示相加，连接字符串表示相连；
			3) 如果字符串本身包含""，可以使用''来表示；如果字符串本身包含''，可以使用""来表示;
			4) 如果字符串本身既包含''也包含""，可以使用\进行转义；常用转义字符：\n 换行； \t制表符； \\ 表示\本身
			5) 如果字符串本身既包含''也包含""，也可以使用'''来表示；'''一般用于输出多行文本中；
			6) 格式化输出可以指定输出字段的长度，%5.2f表示输出浮点数的小数点后有2位，总共长度为5位，默认为右对齐，不足的左侧补空格；
			%-5.2f表示左对齐，长度不足的右边补空格
			7) 对于格式未定的字段，可以通过类似%*.*f % (5,2,1.80)来设定表示%5.2f
			8) 对于类型不确定的字段输出可以统一用%r表示，%r的格式化指定格式后面再学习。
			9) format输出
					
		2. input raw_input输入
			>>> raw_var = raw_input("please input your content:")
			please input your content:Testing python
			>>> print raw_var
			Testing python
			>>> type(raw_var)
			<type 'str'>
			>>> 
			>>> var = input("please input your content:")
			please input your content:'Testing python'
			>>> print var
			Testing python
			>>> type(var)
			<type 'str'>
			>>> var = input("please input your content:")
			please input your content:Testing python
			Traceback (most recent call last):
			File "<stdin>", line 1, in <module>
			File "<string>", line 1
				Testing python
							^
			SyntaxError: unexpected EOF while parsing
			>>> 
			
			>>> raw_var = raw_input("please input your content:")
			please input your content:100+300
			>>> print raw_var
			100+300
			>>> 
			>>> var = input("please input your content:")
			please input your content:100+300
			>>> print var
			400

			>>> age = input('please input your age:')
			please input your age:18
			>>> print age
			18
			>>> type(age)
			<type 'int'>
			>>> 
			
		总结：
			1) raw_input将所有输入作为字符串看待，返回也是字符串类型
			2) input 没有将所有输入作为字符串看待，所以在输入字符串内容时候需要添加引号，否则会出错
			3) input可以接收表达式，并返回表达式结果
			4）input返回也不一定是字符串类型；如果接收的是带引号的字符串那么返回的才是字符串类型；
		
	二. 数据类型和变量
		1. 字符串
			字符串除了上述输入输出用法之外，还有一些内部函数使用,可以通过help(str)查看
			1) format 格式化输出字符串
			>>> print "{} is {} years old and he is studing {}".format('Tester',19,'Python')
			Tester is 19 years old and he is studing Python
			2) len 计算字符串的长度
			>>> print len('Hello world')
			11
			3) endswith 检查字符串是否以给定字符串结尾
			>>> print 'hello world'.endswith('d')
			True
			>>> print 'hello world'.endswith('d',8,11)
			True
			>>> print 'hello world'.endswith('d',8,10)
			False
			4) startswith() 检查字符串是否以给定字符串开始
			>>> print 'hello world'.startswith('h')
			True
			>>> print 'hello world'.startswith('h',2,11)
			False
			>>> print 'hello world'.startswith('e',2,11)
			False
			>>> print 'hello world'.startswith('e',1,11)
			True
			5) upper() 将字符串所有字符变成大写
			>>> print 'hello world'.upper()
			HELLO WORLD
			6) lower() - 将字符串所有字符变成小写
			>>> print 'hello world'.lower()
			hello world
			>>> print 'hello WORLD'.lower()
			hello world
			7) isupper()/islower() - 检测字符串是否全是大写/小写
			>>> print 'hello world'.islower()
			True
			>>> print 'hello World'.islower()
			False
		
		2. 布尔类型
		3. 整数
		4. 浮点数
		5. 空值
		空值是Python里一个特殊的值，用None表示。
		
		变量：
			1) 变量不需要声明，不需要删除，可以直接回收适用。可以使用type()来查看变量的数据类型。
			2) type和isinstance的区别：当有目标类型进行判断时候，可以使用isinstance;当未知类型需要查看可以使用type,
			type不适用于子类的类型判断；
			3) 另外看上去貌似type只能用于继承object类的类型判断，如果下面A不是继续object，那么type(A())结果是不同的；
			>>> class A(object):
			... 	pass
			... 
			>>> class B(A):
			... 	pass
			... 
			>>> a = A()
			>>> b = B()
			>>> type(a) 
			<class '__main__.A'>
			>>> type(b)
			<class '__main__.B'>
			>>> type(a) is A
			True
			>>> type(b) is B
			True
			>>> type(b) is A
			False
			>>> isinstance(a, A)
			True
			>>> isinstance(b, B)
			True
			>>> isinstance(b, A)
			True
			>>> 
			
			>>> class A:
			... 	pass
			... 
			>>> a=A()
			>>> type(a)
			<type 'instance'>
		
		
	三. 条件判断和循环
		1. if条件判断
			a=5
			if a<=5:
				print a,'<=5'
			elif a<=10:
				print a, '<=10'
			else:
				print a,'>10'

		2. for循环
			names = ['Michael', 'Bob', 'Tracy']
			for name in names:
    			print name
	
    		>> for x in range(5):
			... 	print x
			... 
			0
			1
			2
			3
			4

		3. while循环
			a=0
			while a<=5:
				print a
				a=a+1

			while True:
				print a
				a=a+1
				if a>5:
					break


	四. 数据结构
		1. List
			>>> a=[2,1,2]
			>>> a[0]=3		    
			>>> a
			[3, 1, 2]
			>>> b
			[4, 7, 6, 10]
			>>> a.append(5)
			>>> a
			[3, 1, 2, 5]
			>>> a.extend(b)
			>>> a
			[3, 1, 2, 5, 4, 7, 6, 10]
			>>> a.insert(0,9)
			>>> a
			[9, 3, 1, 2, 5, 4, 7, 6, 10]
			>>> a.insert(1,8)
			>>> a
			[9, 8, 3, 1, 2, 5, 4, 7, 6, 10]
			>>> a.insert(5,1)
			>>> a
			[9, 8, 3, 1, 2, 1, 5, 4, 7, 6, 10]
			>>> a.remove(1)
			>>> a
			[9, 8, 3, 2, 1, 5, 4, 7, 6, 10]
			>>> a.pop(0)
			9
			>>> a
			[8, 3, 2, 1, 5, 4, 7, 6, 10]
			>>> a.pop()
			10
			>>> a
			[8, 3, 2, 1, 5, 4, 7, 6]
			>>> a.index(1)
			3
			>>> a.insert(2,6)
			>>> a
			[8, 3, 6, 2, 1, 5, 4, 7, 6]
			 >>> a.count(3)
			1
			>>> a.count(6)
			2
			>>> a.sort()
			>>> a
			[1, 2, 3, 4, 5, 6, 6, 7, 8]
			>>> a.reverse()
			>>> a
			[8, 7, 6, 6, 5, 4, 3, 2, 1]
			>>> len(a)
			9

			>>> a=[8, 7, 6, 6, 5, 4, 3, 2, 1]
			>>> b=a
			>>> del a[0]
			>>> a
			[7, 6, 6, 5, 4, 3, 2, 1]
			>>> b
			[7, 6, 6, 5, 4, 3, 2, 1]
			>>> del a
			>>> a
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			NameError: name 'a' is not defined
			>>> b
			[7, 6, 6, 5, 4, 3, 2, 1]
			>>> 
			>>> a=[8, 7, 6, 6, 5, 4, 3, 2, 1]
			>>> b=a
			>>> a.pop(0)
			8
			>>> a
			[7, 6, 6, 5, 4, 3, 2, 1]
			>>> b
			[7, 6, 6, 5, 4, 3, 2, 1]
			>>> a.remove(6)
			>>> a
			[7, 6, 5, 4, 3, 2, 1]
			>>> b
			[7, 6, 5, 4, 3, 2, 1]
			>>>

			>>> a=[1,2]
			>>> b=[3,4]
			>>> a+b
			[1, 2, 3, 4]
			>>> 

			>>> a=[1,2,3,4]
			>>> a.index(8)
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			ValueError: 8 is not in list
			>>> a.count(8)
			0
			>>> a.index(1)
			0
			>>> a.count(1)
			1
			>>> 
			>>> a=[1,2,3,4]
			>>> 3 in a
			True
			>>> 5 in a
			False
			>>> 

		总结: 
			1) list是一种有序的集合，可以随时添加和删除其中的元素; 空列表定义a=[]
			2) 可以用索引访问其中元素，索引从0开始；当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，最后一个元素的索引是len(a) - 1
			3) 如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素,以此类推，可以获取倒数第2个、倒数第3个
			4) list相关函数，可以通过help(list)查看
			添加：
			append(元素) : 末尾添加元素
			extend(列表) : 合并另外一个列表
			insert(索引位置，元素): 在某个位置插入元素
			删除：
			remove(元素): 删除指定元素，如果有多个相同元素只删除第一个；
			pop(索引位置): 删除指定位置元素，如果不指定表示删除最后一个元素；
			修改：
			直接根据列表索引位置重新赋值即可，注意首先必须保证索引位置没有超出列表的索引范围；
			>>> a=[]
			>>> a[0]=3
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			IndexError: list assignment index out of range
			查询：
			index(元素): 根据元素内容查询其所在的索引位置;
			count(元素）: 统计某个元素在列表中有多少个；
			index和count的区别： 两者都可以用来查询列表元素，如果元素不在列表中的话index会出现异常，而count会返回0
			判断某个元素是否存在于列表中也可以使用in的方法

			len(列表): 统计列表的长度，也就是有多少个元素；
			sort(): 
			reverse(): 
			注： 两个列表相并除了用extend方法，用+也是相同效果
			5) 删除列表元素del,remove,pop的区别

			>>> a=[1,2]
			>>> b=[3,4]
			>>> a+b
			[1, 2, 3, 4]
			>>> a*2
			[1, 2, 1, 2]

		2. Tuple
			>>> m=(6,8,10,6)
			>>> m.count(6)
			2
			>>> m.count(10)
			1
			>>> m.index(10)
			2
			>>> m.index(6)
			0

			>>> a=(1,)
			>>> type(a)
			<type 'tuple'>
			>>> a=(1)
			>>> type(a)
			<type 'int'>

			>>> m=(1,2)
			>>> m
			(1, 2)
			>>> a=['a','b']
			>>> m=(1,2,a)
			>>> m
			(1, 2, ['a', 'b'])
			>>> a.append('c')
			>>> a
			['a', 'b', 'c']
			>>> m
			(1, 2, ['a', 'b', 'c'])

			>>> a=(1,2,3,4)
			>>> a.index(0)
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			ValueError: tuple.index(x): x not in tuple
			>>> a.count(0)
			0
			>>> a.index(1)
			0
			>>> a.count(1)
			1
			>>> 

		总结：
			1) tuple称为元组，有序但是元素不可变更，一旦初始化之后就不能再修改；空元组定义为 a=()
			2) tuple也可以通过索引访问元素，索引从0开始
			3) tuple相关函数：
			index（元素): 和列表相同也是根据元祖内容查询它的索引位置；
			count(元素): 和列表一样也是统计某个元素出现的次数；
			index和count的区别： 两者都可以用来查询tuple元素，如果元素不在tuple中的话index会出现异常，而count会返回0

			4) 只有一个元素的元组，定义为a=(1,)，不能定义为a=(1);
			5) 元组的不可变更是指元组的元素指向不可更新，如果元素指向某个列表的时候，列表的内容更新不受限制；

		3. dict
		    创建字典
			>>> g={'linken':'male','aobama':'male','xilali':'female'}
			>>> g
			{'aobama': 'male', 'xilali': 'female', 'linken': 'male'}

			访问字典元素
			>>> g['xilali']
			'female'
			>>> for key in g:
			... 	print key,g[key]
			... 
			aobama male
			xilali female
			linken male

			>>> 'xilali' in g
			True
			>>> 'xibushi' in g
			False
			>>> g.get('xilali')
			'female'
			>>> g.get('xibushi')
			>>> g.get('xibushi',2)
			2
			>>> g.get('xilali',2)
			'female'
			>>> g.has_key('xilali')
			True

			修改字典
			>>> g['xibushi']='female'
			>>> g
			{'aobama': 'male', 'xibushi': 'female', 'xilali': 'female', 'linken': 'male'}
			>>> g['xibushi']='male'
			>>> g
			{'aobama': 'male', 'xibushi': 'male', 'xilali': 'female', 'linken': 'male'}
			>>> k={'jj':'male'}
			>>> g.update(k)
			>>> g
			{'aobama': 'male', 'linken': 'male', 'jj': 'male', 'xilali': 'female', 'xibushi': 'male'}
			>>> n={'aobama':'female'}
			>>> g.update(n)
			>>> g
			{'linken': 'male', 'jj': 'male', 'xilali': 'female', 'aobama': 'female', 'xibushi': 'male'}

			update方法更新字典，如果两个字典元素中key值有重复则取用新的value

			删除字典
			>>> g = {'aobama': 'male', 'xibushi': 'male', 'xilali': 'female', 'linken': 'male'}
			>>> g.pop('xibushi')
			'male'
			>>> g
			{'aobama': 'male', 'xilali': 'female', 'linken': 'male'}
			>>> del g['aobama']
			>>> g
			{'linken': 'male', 'xilali': 'female'}
			>>> g.clear()
			>>> g
			{}
			>>> g={'linken': 'male', 'xilali': 'female'}
			>>> del g
			>>> g
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			NameError: name 'g' is not defined

			函数：
			>>> g={'linken': 'male', 'xilali': 'female'}
			>>> g.items()
			[('xilali', 'female'), ('linken', 'male')]
			>>> g.keys()
			['xilali', 'linken']
			>>> g.values()
			['female', 'male']
			>>> g
			{'xilali': 'female', 'linken': 'male'}
			>>> g.setdefault('aobama','male')
			'male'
			>>> g
			{'xilali': 'female', 'aobama': 'male', 'linken': 'male'}
			>>> g.setdefault('aobama','male')
			'male'
			>>> g
			{'xilali': 'female', 'aobama': 'male', 'linken': 'male'}
			>>> g.setdefault('aobama','female')
			'male'
			>>> g
			{'xilali': 'female', 'aobama': 'male', 'linken': 'male'}

			>>> a
			('xilai', 'aobama')
			>>> v
			('femail', 'male')
			>>> dict.fromkeys(a,v)
			{'xilai': ('femail', 'male'), 'aobama': ('femail', 'male')}

			字典遍历：
			>>> for key in m:
			... 	print key,m[key]
			... 
			xilai ('femail', 'male')
			aobama ('femail', 'male')

			>>> for (k,v) in m.items():
			... 	print "m[%s] = %r" % (k, v)
			... 
			m[xilai] = ('femail', 'male')
			m[aobama] = ('femail', 'male')
			
		总结：
			1) dict全称dictionary，使用键-值（key-value）存储; 空字典 a={}; 支持增删改查操作；
			2) 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入;
			3) 由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉;
			4) 要避免key不存在的错误，有三种办法，一是通过in判断key是否存在：二是通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value；还可以通过函数has_key进行判断(这种一般不用了)；
			5) 要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
				del a[key] 也可以删除某个元素
				del a 删除整个字典
			6) 请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。
			　　和list比较，dict有以下几个特点：
			　　　　　查找和插入的速度极快，不会随着key的增加而增加；
			　　　　　需要占用大量的内存，内存浪费多。
			　　而list相反：
			　　　　　查找和插入的时间随着元素的增加而增加；
			　　　　　占用空间小，浪费内存很少。
			　　所以，dict是用空间来换取时间的一种方法。
			7) dict的key必须是不可变对象,这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key.
			8) dict的常用函数,help(dict)可以查看
			clear()：删除字典内所有元素
			get(key, default=None)：返回指定键的值，如果值不在字典中返回default值
			has_key(key)：如果键在字典dict里返回true，否则返回false
			items()：以列表返回可遍历的(键, 值) 元组数组
			keys()：以列表返回一个字典所有的键
			values()：以列表返回字典中的所有值
			update(dict2)：把字典dict2的键/值对更新到dict里
			setdefault(key, default=None)：
			     和get()类似, 如果键已经存在于字典中则返回字典中对应的value；但如果键不存在于字典中，将会添加键并将值设为default值;
			len(dict)：计算字典元素个数，即键的总数。
			fromkeys(seq,val)：创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值
			...

			>>> a=(1,2,[3,4])
			>>> b={a:"oo"}
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			TypeError: unhashable type: 'list'
			>>>

			>>> a=(1,2)
			>>> m={a:'pp'}
			>>> 
			在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key.
			另外元祖虽说也是不可变，但是实际元祖中的元素本身可以指向可变对象，所以包含可变对象元素的元祖也不可以作为字典的键，不包含可变对象的元素的元组可以作为字典的键。

		4. Set
		　　(用途：去重，比较)
			定义：注意必须要有set关键字。
			>>> a=set(['linken','xilali','aobama'])
			>>> a
			set(['xilali', 'aobama', 'linken'])
			>>> a=set(['linken','xilali','aobama','linken'])
			>>> a
			set(['xilali', 'aobama', 'linken'])
			
			增加：
			>>> a.add('xibushi')
			>>> a
			set(['xilali', 'aobama', 'xibushi', 'linken'])
			
			删除：
			>>> a.remove('xibushi')
			>>> a
			set(['xilali', 'aobama', 'linken'])

			>>> b=[1,2]
			>>> a.add(b)
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			TypeError: unhashable type: 'list'
			>>> m=(1,2)
			>>> a.add(m)
			>>> a
			set([(1, 2), 'xilali', 'aobama', 'linken'])
			>>> n=(1,2,[3,4])
			>>> a.add(n)
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			TypeError: unhashable type: 'list'

		总结：
			1)set也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key,重复元素在set中自动被过滤：
			2)dict的key值以及set的内容都只能存放不可变对象,所以这里添加列表b会失败，但是添加元祖m成功，但是添加包含列表的元祖也会失败
			3)set常用函数,help(set)查看

		5. 不可变对象：
			>>> a = 'abc'
			>>> b = a.replace('a', 'A')
			>>> b
			'Abc'
			>>> a
			'abc'
			说明：
			1) a是变量，而'abc'才是字符串对象。当调用a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了：

		总结：
			1) 可变类型： 列表，字典　
			2) 不可变类型：数字，字符串，元组(元组实际需要看实际它的元素是否为可变对象)

			>>> a='anc'
			>>> b='anc'
			>>> id(a)
			40842448
			>>> id(b)
			40842448
			>>> a="mmm"*100
			>>> b="mmm"*100
			>>> id(a)
			1635320
			>>> id(b)
			1635648

			同一个数值赋给两个不同变量，两个变量可能是指向同一块内存；但如果数值太大，也可能不是同一块内存；
		
		6. 深拷贝浅拷贝：
			>>> import copy
			>>> a=['Tom',18,['chinese','english']]
			>>> b=a
			>>> c=copy.copy(a)
			>>> d=copy.deepcopy(a)
			>>> a[0]='David'
			>>> a
			['David', 18, ['chinese', 'english']]
			>>> b
			['David', 18, ['chinese', 'english']]
			>>> c
			['Tom', 18, ['chinese', 'english']]
			>>> d
			['Tom', 18, ['chinese', 'english']]
			>>> a[2][0]='Hongkong'
			>>> a
			['David', 18, ['Hongkong', 'english']]
			>>> b
			['David', 18, ['Hongkong', 'english']]
			>>> c
			['Tom', 18, ['Hongkong', 'english']]
			>>> d
			['Tom', 18, ['chinese', 'english']]
			>>> 

		总结（浅拷贝依然使用原始地址引用，深拷贝和原始完全脱离关系一切都是新的）：
			1) Python中对象的赋值都是进行对象引用（内存地址）传递
			2) 使用copy.copy()，可以进行对象的浅拷贝，它复制了对象，但对于对象中的元素，依然使用原始的引用.
			3) 会产生浅拷贝效果的操作：
			   使用切片[:]操作
			   使用工厂函数（如list/dict/set）（??)
			   使用copy模块中的copy()函数
			4) 如果需要复制一个容器对象，以及它里面的所有元素（包含元素的子元素），可以使用copy.deepcopy()进行深拷贝
			参考地址：http://python.jobbole.com/82294/

	五. 面向对象
	    1. 类的定义和实例化
			class dog():                
			    def __init__(self,name,age,s,color):    
			        self.name = name
			        self.age = age
			        self.single = s
			        self.color = color
			    def walk(self):
			        self.a = 'aaa'
			        self.b = 100
			        print 'running dog'
			    def eat(self,food):
			        print 'eat..',food
			    def talk(self):
			        print 'w w w'
			w = dog('heizi',1,True,'black')     
			l = dog('nana',3,True,'yellow')
			l.money = 'bumai!'
			print l.money
			print w.name

		总结：
			1) class后面紧接着是类名，类的类型分为经典类和新式类。经典类后面括号不继承任何东西。新式类括号里面面一般最好添加(object),表示该类是从哪个类继承下来的。通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。
			2) 由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填进去。通过定义一个特殊的__init__方法，在创建实例的时候，就把name，age等属性绑上去
			3) 注意到__init__为初始化方法，第一个参数永远是self，表示创建的实例本身
			4) 变量w就是指向dog的类的实例变量，而dog本身就是一个类。（）里面的都是给他捆绑的属性
			5) 有了__init__方法，在创建实例的时候，就不能传入空的参数了，必须传入与__init__方法匹配的参数，但self不需要传，Python解释器自己会把实例变量传进去。另外和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数和关键字参数。
			6) 类的方法：在上面的dog类中，每个实例就拥有各自的name和age这些数据，因为dog的实例本身就有这些数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在dog类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和dog类本身是关联起来的，我们称之为类的方法。要定义一个方法，除了第一个参数是self外，其他和普通函数一样。要调用一个方法，只需要在实例变量上直接调用，除了self不用传递，其他参数正常传入。


		2. 属性
				class student(object):
					grade = 'Four'       #类的公有属性，可以被类和实例访问
					__teacher = 'David'  #类的私有属性(以__为前缀)，不可以被类和实例访问，只可用于类的方法中调用
				
					def __init__(self,name,age):
						self.name = name #实例的公有属性，可以被实例访问
						self.__age = age #实例的私有属性(以__为前缀)，不可以被实例访问，只可用于类的方法中
				
					def getGrade(self):
						print self.grade
				
					def getTeacher(self):
						print self.__teacher
				
					def getName(self):
						print self.name
				
					def getAge(self):
						print self.__age
				
				s = student('Lina',18)
				print '---测试1：类的公有属性可以被类和实例访问'
				print student.grade
				print s.grade
				
				print '---测试2：类的私有属性不可以被类和实例访问'
				#print student.__teacher
				#print s.__teacher
				
				print '---测试3: 实例的公有属性，可以被实例访问，但是不能被类访问'
				print s.name
				#print student.name
				
				print '---测试4, 实例的私有属性，不可以被实例访问'
				#print s.__age
				
				print '---测试5, 公有属性和私有属性都可以被类的方法中调用'
				s.getGrade()
				s.getTeacher()
				s.getName()
				s.getAge()

		总结：
		    属性分为类的属性和实例属性。定义在类中方法之外的属性，称为类的属性，又分为类的公有属性和私有属性；
			1) 类的公有属性，可以被类和实例访问；
			2) 类的私有属性(以__为前缀)，不可以被类和实例访问，只可用于类的方法中通过self.__private_attrs调用
			3) 实例的公有属性，可以被实例访问
			4) 实例的私有属性(以__为前缀)，不可以被实例访问，只可用于类的方法中通过self.__private_attrs调用
			5) 如果类的公有属性和实例公有属性同名，则两者互相不影响；

			（类和实例的私有属性都是只能被类中定义的方法使用)

		3. 方法
				class student(object):
					grade = 'Four'       #类的公有属性，可以被类和实例访问
					__teacher = 'David'  #类的私有属性（以__为前缀)，不可以被类和实例访问，只可用于类的方法中调用
				
					def __init__(self,name,age):
						self.name = name #实例的公有属性，可以被实例访问
						self.__age = age #实例的私有属性（以__为前缀)，不可以被实例访问，只可用于类的方法中
				
					def getGrade(self):
						print self.grade
				
					def getTeacher(self):
						print self.__teacher
				
					def getName(self):
						print self.name
				
					def __getAge(self):  #私有方法（以__为前缀)，不可以被实例访问
						print self.__age
				
					def getAge(self):    #公有方法，可以被实例访问
						self.__getAge()
				
				s = student('Lina',18)
				print '---测试1：类的公有属性可以被类和实例访问'
				print student.grade
				print s.grade
				
				print '---测试2：类的私有属性不可以被类和实例访问'
				#print student.__teacher
				#print s.__teacher
				
				print '---测试3: 实例的公有属性，可以被实例访问，但是不能被类访问'
				print s.name
				#print student.name
				
				print '---测试4, 实例的私有属性，不可以被实例访问'
				#print s.__age
				
				print '---测试5, 公有属性和私有属性都可以被类的方法中调用'
				s.getGrade()
				s.getTeacher()
				s.getName()
				
				print '---测试6, 私有方法不可以被实例访问'
				#s.__getAge()
				s.getAge()

				class Dav(student):
					grade = 'one'
					__teacher = 'Mrliu'
					def __init__(self,name,age):
						self.name = name
						self.__age = age
				
					@staticmethod
					def getStu():
						#print self.grade
						#print self.__teacher
						#print self.name
						#print self.__age
						print '调用静态方法'
				
					@classmethod
					def getInfo(cls):
						print cls.grade
						print cls.__teacher
						#print self.name
						#print self.__age
						print '调用类方法'
				
				print '---测试10: 静态方法不能访问类和实例的属性，定义时候也不需要加self参数，可以被实例或者类调用且两者效果一致'
				d = Dav('david', 21)
				d.getStu()
				Dav.getStu()
				
				print '---测试11: 类方法可以访问类的属性,包含类的公有属性和私有属性，可以被实例或者类调用且两者效果一致'
				dd = Dav('tom', 23)
				dd.getInfo()
				Dav.getInfo()

		总结：
		    方法包含实例方法，静态方法，类方法。
			1) 私有方法以两个下划线开头，不可以被实例访问，只能在类的方法中通过self.__private_methods调用
			2) 公有方法，可以被实例访问
			3) 以上说的方法实际都是实例方法，其它还有静态方法，类方法。
			4) 静态方法使用装饰器@staticmethod定义，并且方法参数中不能有self. 类对象和实例都可以调用静态方法,但是无法访问类属性、实例属性，相当于一个相对独立的方法，跟类其实没什么关系;
			5) 类方法使用@classmethod装饰器定义，其第一个参数必须为cls，且不需要self参数。类对象和实例都可以调用类方法,可以访问类属性包含公有属性和私有属性，但是无法访问实例属性。

			
			还有一种类中普通的方法（没有self参数)，这种方法既可以被类直接调用也可以被类的实例对象调用，但是被实例对象调用的时候，要求方法至少有一个参数，因为调用时会将实例对象本身传给第一个参数。staticmethod函数功能就是将这种方法定义成类的静态方法，正确的方法是使用 @staticmethod装饰器，这样在实例对象调用的时候，不会把实例对象本身传入静态方法的第一个参数了。

	    4. 构造方法
			class student(object):
				grade = 'Four'       #类的公有属性，可以被类和实例访问
				__teacher = 'David'  #类的私有属性（以__为前缀)，不可以被类和实例访问，只可用于类的方法中调用
			
				def __init__(self,name,age):
					self.name = name #实例的公有属性，可以被实例访问
					self.__age = age #实例的私有属性（以__为前缀)，不可以被实例访问，只可用于类的方法中
					print '父类构造函数'
			
				def getGrade(self):
					print self.grade
			
				def getTeacher(self):
					print self.__teacher
			
				def getName(self):
					print self.name
			
				def __getAge(self):  #私有方法（以__为前缀)，不可以被实例访问
					print self.__age
			
				def getAge(self):    #公有方法，可以被实例访问
					self.__getAge()
			
			s = student('Lina',18)
			print '---测试1：类的公有属性可以被类和实例访问'
			print student.grade
			print s.grade
			
			print '---测试2：类的私有属性不可以被类和实例访问'
			#print student.__teacher
			#print s.__teacher
			
			print '---测试3: 实例的公有属性，可以被实例访问，但是不能被类访问'
			print s.name
			#print student.name
			
			print '---测试4, 实例的私有属性，不可以被实例访问'
			#print s.__age
			
			print '---测试5, 公有属性和私有属性都可以被类的方法中调用'
			s.getGrade()
			s.getTeacher()
			s.getName()
			
			print '---测试6, 私有方法不可以被实例访问'
			#s.__getAge()
			s.getAge()
			
			
			class Liming(student):
				def getName(self):
					print self.name
			
			print '---测试7, 子类未定义构造函数，将默认使用父类构造函数'
			l = Liming('liming', 20)
			l.getName()
			
			
			class Liutao(student):
				def __init__(self,name,age,height):
					self.name = name
					self.age =age
					self.height = height
					print '子类自己的构造函数'
			
				def getName(self):
					print self.name
			
			print '--测试8,子类定义了构造函数，实例化将使用自己的构造函数'
			lt = Liutao('liutao', 35, 168)
			lt.getName()
			
			class litao2(student):
				def __init__(self,name,age,height):
					student.__init__(self,name,age)
					self.height =height
					print '子类自己的构造函数'
			
				def getName(self):
					print self.name
			
			print '---测试9，子类定义了构造函数，还可以继续调用父类构造函数'
			lt2 = litao2('litao2',20,180)	
			lt2.getName()

		总结：
			1) 如果子类没有定义构造函数，将默认使用父类构造函数；
			2) 如果一个子类从多个父类派生，而子类又没有自己的构造函数,则按顺序继承，
			哪个父类在最前面且它又有自己的构造函数，就继承它的构造函数；如果最前面第一个父类没有构造函数，
			则继承第2个的构造函数，第2个没有的话，再往后找，以此类推。
			3) 如果子类有自己的构造函数，不会自动调用父类的构造函数，只会调用自己的构造函数
			4) 如果需要用到父类的构造函数，则需要在子类的构造函数中显式的调用
			5) 显式调用父类构造函数有两种方法：super以及 通过父类直接调用__init__函数；

		5. 多态
			class A():
				def login(self):
					print 'A'

			class B(A):
				def login(self):
					print 'B'

			class C(A):
				def login(self):
					print 'C'

			def test(a)
				a.login()

			test(B()) 
			test(A())
			test(C())

		总结：
			1) 如果父类方法的功能不能满足需求，可以在子类重写父类的方法。实例对象调用方法时会调用其对应子类的重写后的方法


		6. 继承
			class A:
				pass

			class B(A):
				pass

		总结：
		1) 定义：class 派生类名（基类名)
		2) 特点：
		   I: 在继承中基类的构造（__init__()方法）不会被自动调用，它需要在其派生类的构造中亲自专门调用。使用super().__init__()或parentClassName.__init__()
		   II: 在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。区别于在类中调用普通函数时并不需要带上self参数
		   III: 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。

 		7. 封装


 	六. 错误处理机制
 		1. 默认异常处理
 			s = 'Hello girl!'
			print s[100]
			print 'continue'   #这一句不会执行

		2. try..finally
			s = 'Hello world!'
			try:
				print s[100]
			finally:
				print 'alwas run here...'
			print 'continue'   #这一句不会执行

 		2. try..except..
 			s = 'Hello world!'
			try:
				print s[100]
			except IndexError as e:
				print 'error is:',e
			print 'continue'    #这一句会执行

		3. try..except..else..finally
			s = 'Hello world!'
			try:
				print s[0]
			except IndexError as e:
				print 'error is:',e
			else:
				print 'run here if no error'
			finally:
				print 'always run here'
			print 'continue'

		4.  try..except..except..finally
			s = 'Hello world!'
			try:
				print S[100]
			except IndexError as e:
				print 'error is:',e
			except NameError as e:
				print 'Error is:', e
			finally:
				print 'always run here'
			print 'continue'   #这一句会执行

		总结：
			1) 如果没有对异常进行任何处理，那么在程序执行的过程中发生异常，就会中断程序，调用python默认的异常处理器，并在终端输出异常信息。这种情况下，后续代码不会继续执行。
			2) finally语句表示，无论异常发生与否，finally中的语句都要执行。所以1和2最后print 'continue'都不会执行，但是2中finally会执行。
			3) 程序执行到发现try语句，进入try语句块执行，发生异常，回到try语句层，寻找后面是否有except语句。找到except语句后，会调用这个自定义的异常处理器。except将异常处理完毕后，程序继续往下执行; 如果没有except块程序程序在执行完finally后会自动调用默认异常处理。
			4) else表示没有异常时候会执行； except可以有多个，后面也可以为空，表示捕获任何类型的异常；

	七. 文件操作
		1. 打开
			open(name,mode,buff)
			mode分为：
			'r' 只读方式, 打开的文件必须存在
			'w' 只写方式，打开文件不存在会自动创建，写入文件会自动清空原始内容
			'a' 追加方式，打开文件不存在会自动创建，写入文件不会清空原始内容
			'r+' 读写方式打开, 打开的文件必须存在, 写入文件会覆盖原始文件中相同长度的内容（？）
			'w+' 读写方式打开, 打开的文件不存在会自动创建，写入文件会自动清空原始内容
			'a+' 追加读写方式打开，文件不存在会自动创建，写入文件不会清空原始内容
			rb wb ab rb+ wb+ ab+ ：二进制方式打开
			r+ w+ a+三种操作方式不可open之后同时进行读写操作，但是同一个操作可以多次

			r+操作:
			>>> file = open('1.txt','r')
			>>> file.read()
			'ddff'
			>>> file.close()
			>>> 
			>>> file = open('1.txt','r+')
			>>> file.write('ggg')
			>>> file.close()
			>>> 
			>>> file = open('1.txt','r')
			>>> file.read()
			'gggf'
			>>> 


			w+操作： writelines写入内容为什么在同一行？？
			>>> file = open('1.txt','w+')
			>>> file.read()
			''
			>>> file.close()
			>>> file = open('1.txt','w+')
			>>> file.write('test')
			>>> file.writelines(['123','rttt'])
			>>> file.close()
			>>> 
			>>> file = open('1.txt','r')
			>>> file.read()
			'test123rttt'
			>>> file.close()

		2. 读取
			1)  read(size)： 
				每次从文件中读取size个字节，没有size表示读取全部，返回字符串类型
				>>> f= open('1.txt','r')
				>>> f.read(2)
				'12'
				>>> f.read(100)
				'3\nfg'
				>>> f.close()
				>>> 
				>>> 
				>>> f= open('1.txt','r')
				>>> f.read()
				'123\nfg'
				>>> f.read()
				''
				>>> f.close()
				>>> 
				>>> f= open('1.txt','r')
				>>> f.read(2)
				'12'
				>>> f.read(2)
				'3\n'
				>>> f.read()
				'fg'
				>>> f.close()
			2） readline(size): 
				每次从一行中读取size个字节，一行不够size的也只输出一行,没有指定size的也是读取一行，返回字符串类型
				>>> f= open('1.txt','r')
				>>> f.read()
				'mmmmmkkkkklllll\nqqqqqooooonnnnn'
				>>> f.close()
				>>> 
				>>> f= open('1.txt','r')
				>>> f.readline(10)
				'mmmmmkkkkk'
				>>> f.readline(5)
				'lllll'
				>>> f.readline(100)
				'\n'
				>>> f.readline(100)
				'qqqqqooooonnnnn'
				>>> 
			3） readlines(size) ：	
				没有指定size表示读取完全部文件内容，将每一行以列表形式返回；如果指定了size,这个size不是指每次读取的字节大小，而将这个size调整为io.DEFAULT_BUFFER_SIZE大小的整数倍，而且每次返回的肯定都是完整的行数据。一般应用于读取比较大的，比如读取2G文件，可以指定每次读取1sise设置为100M），这样每次读取就会自动返回大约100M的数据。大多数情况下，返回的数据的字节数会size指定的值大一点（除最后一次调用 readlines(sizehint) 函数的时候）。 
			    >>> io.DEFAULT_BUFFER_SIZE	
				8192

			4） 将文件转换成迭代器读取
				>>> f= open('1.txt','r')
				>>> f=iter(f)
				>>> for line in f:
				... 	print line
				... 
				mmmmmkkkkklllll
				
				qqqqqooooonnnnn
				>>> 
		3. 写入

			1) write(str): 将一个字符串写入文件，并不会在str后加上一个换行符
				>>> f = open('1.txt','w')
				>>> f.write('testing')
				这个时候看不到文件内容，需要通过close()或者flush()来同步缓存内容到硬盘。
	
				>>> f = open('1.txt','w')
				>>> for i in range(10000):
				... 	f.write("testing write operation {}\n".format(i))
	
				这个时候还未close或者flush，但是也可以查看到写入的部分文件内容,还有没有看到的内容也就是超出缓存大小的内容需要通过close或者flush来同步。

			2） writelines（sequence of strs): 将多个字符串放进一个序列然后写入文件，也不会添加换行符。

			总结： 
			python在执行write操作之后，并不会直接写到硬盘，而是写到缓存，从缓存到磁盘的操作需要下面方法触发：
			1) 调用close()方式或者flush()方法，这个时候写缓存才会自动同步到硬盘；
			2) 写入数据量大于或者等于写缓存，这个时候写缓存也会自动同步到磁盘；

		4. 文件读取指针
			1) 写入文件之后，必须重新打开文件才能读取写入内容
			2) 读取文件之后，无法再次重新读取读过得内容
			通过文件指针可以解决上面两个问题：
			seek(offset,where):  where=0从起始位置移动，1从当前位置移动，2从结束位置移动。offset正数表示向后移动，负数表示向前移动
			tell():  文件的当前位置,即tell是获得文件指针位置，受seek、readline、read、readlines影响，不受truncate影响
			truncate(n):  从文件的首行首字符开始截断，截断文件为n个字符；无n表示从当前位置起截断；截断之后n后面的所有字符被删除。
			readline(n):读入若干行，n表示读入的最长字节数。其中读取的开始位置为tell()+1。当n为空时，默认只读当前行的内容
			readlines()读入所有行内容
			read()读入所有行内容
			>>> f=open('1.txt','r')
			>>> f.tell()
			0L
			>>> f.seek(2,0)
			>>> f.tell()
			2L
			>>> f.readline()
			'llo world\n'
			>>> f.seek(-2,1)
			>>> f.tell()
			11L
			>>> f.readline()
			'\n'
			>>> f.seek(-5,2)
			>>> f.readline()
			' file'
			>>> f.seek(0,0)
			>>> f.readline()
			'hello world\n'
			>>> f.tell()
			13L

http://lib.csdn.net/base/python/structure

HTTP:

	1. 流程
		浏览器    web服务器
		
		request
		------------------>
		response
		<-----------------
		解析html

	2. 请求格式
		1). 请求行 : 包含请求方法，请求资源，HTTP协议的版本号
		　GET http://www.cnblogs.com/ HTTP/1.1
		2). 请求头: 包含若干请求字段，比如Host表示请求的服务器域名
		3). 空行
		4). 请求body：　当使用的是"GET" 方法的时候， body是为空的
		
		GET /hello.txt HTTP/1.1
		User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
		Host: www.example.com
		Accept-Language: en, mi

	3. 响应格式：
		1). 响应行: 包含HTTP协议的版本号,响应码,响应描述
			HTTP/1.1 200 ok
		2). 响应头： 包含若干响应字段，比如Content-Type表示响应的数据类型
		3). 空行
		4). 响应body：
		
		HTTP/1.1 200 OK
		Date: Mon, 27 Jul 2009 12:28:53 GMT
		Server: Apache
		Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
		ETag: "34aa387-d-1568eb00"
		Accept-Ranges: bytes
		Content-Length: 51
		Vary: Accept-Encoding
		Content-Type: text/plain


	4. 请求方法：
		HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。
		HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。
		最基本的有4种，分别是GET,POST,PUT,DELETE对应着对请求资源的查，改，增，删4个操作；

		GET     查看资源
		POST    增加资源
		PUT     修改资源
		DELETE  删除资源
		HEAD    查看响应头
		OPTIONS 查看可用请求方法


		GET和POST的区别：
		1. GET提交的数据会放在URL之后;POST方法是把提交的数据放在HTTP包的Body中;
		2. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制
		3. GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上

	5. 响应码：
		200 - 请求成功
		301 - 资源（网页等）被永久转移到其它URL
		404 - 请求的资源（网页等）不存在
		500 - 内部服务器错误

Request
	http://cn.python-requests.org/zh_CN/latest/
	
	import requests
	url='http://www.baidu.com'
	r = requests.get(url)
	#打印状态码
	print r.status_code
	print r.reason
	#打印网页内容
	print r.content
	print r.text
	print r.json
	
	#打印响应头
	print r.headers
	print r.headers.get('Content-Type')
	#自定义请求头
	headers = {'User-Agent': 'alexkh'}
	r = requests.get(url, headers = headers)
	#打印请求头
	print r.request.headers
	print r.request.headers['User-Agent']


S3	
	1. 创建连接
		import boto
		access_key = ' '
		secret_key = ' '
		conn = boto.connect_s3(
        aws_access_key_id = access_key,
        aws_secret_access_key = secret_key
        )

	2. 列出bucket
		for bucket in conn.get_all_buckets():
			print bucket.name

	3. 创建bucket
		bucket = conn.create_bucket('mybucket')

	4. 列出bucket内容
		for key in bucket.list():
			print key.name

	5. 删除bucket
		conn.delete_bucket(bucket.name)

	6. 创建对象
		key = bucket.new_key('hello.txt')
		key.set_contents_from_string('Hello World!')

	7. 下载对象
		key = bucket.get_key('1.txt')
		key.get_contents_to_filename('1.txt')

	8. 删除对象
		bucket.delete_key('goodbye.txt')



内建函数
	1. zip
		zip函数接受任意多个序列作为参数,将所有序列按相同的索引组合成一个元素是各个序列合并成的tuple的新序列，新的序列的长度以参数中最短的序列为准。另外(*)操作符与zip函数配合可以实现与zip相反的功能，即将合并的序列拆成多个tuple。
		1) 返回带元组的列表
		>>> a='<^>'
		>>> b=['left', 'center', 'right']
		>>> zip(a,b)
		[('<', 'left'), ('^', 'center'), ('>', 'right')]

		>>> name=['tom','david','liu']
		>>> age=[20,23,21]
		>>> zip(name,age)
		[('tom', 20), ('david', 23), ('liu', 21)]

		2) 新的序列长度以短的序列为准
		>>> name=['tom','david','liu','pan']
		>>> age=[20,23,21]
		>>> zip(name,age)
		[('tom', 20), ('david', 23), ('liu', 21)]

		3) *操作符与zip函数配合可以实现与zip相反的功能,将合并的序列拆成多个tuple。(??底下例子如何理解)
		>>> name=['tom','david','liu','pan']
		>>> age=[20,23,21]
		zip(*zip(name,age))
		[('tom', 'david', 'liu'), (20, 23, 21)]

		>>> a=[1,2,3,4,5,6]
		>>> s=zip(*[a]*2)
		>>> s
		[(1, 1), (2, 2), (3, 3), (4, 4), (5, 5), (6, 6)]
		>>> s=zip(*[iter(a)]*2)
		>>> s
		[(1, 2), (3, 4), (5, 6)]

专题:
	1. format格式化
		1) 接受位置参数输出
			>>> '{0}, {1}, {2}'.format('a', 'b', 'c')
			'a, b, c'
			>>> '{}, {}, {}'.format('a', 'b', 'c')  # 2.7+ only
			'a, b, c'
			>>> '{2}, {1}, {0}'.format('a', 'b', 'c')
			'c, b, a'
			>>> '{2}, {1}, {0}'.format(*'abc')      # unpacking argument sequence
			'c, b, a'
			>>> '{0}{1}{0}'.format('abra', 'cad')   # arguments' indices can be repeated
			'abracadabra'
		2) 接受参数名称输出
			>>> print "His name is {name} and age is {age} ".format(age=18,name='Tom')
			His name is Tom and age is 18 
		3) 接受对象属性输出
			>>> class person():
			... 	def __init__(self):
			... 		self.name='Jack'
			... 	def get_name(self):
			... 		print 'his name is {self.name}'.format(self=self)
			>>> p.get_name()
			his name is Jack
		4) 接受序列的数据输出
			>>> a=('tom','Jack','meng')
			>>> print '{0[0]},{0[1]},{0[2]}'.format(a)
			tom,Jack,meng
		5) 格式化输出,可代替%s,%r
			>>> print 'His name is {}'.format('tom')
			His name is tom
			>>> print 'His name is {:10}'.format('tom')
			His name is tom       
			>>> print 'His name is {:<10}'.format('tom')
			His name is tom       
			>>> print 'His name is {:>10}'.format('tom')
			His name is        tom
			>>> print 'His name is {:^10}'.format('tom')
			His name is    tom    
			>>> print 'His name is {:*<10}'.format('tom')
			His name is tom*******
			>>> print 'His name is {:.>10}'.format('tom')
			His name is .......tom
			>>> print 'His name is {:#^10}'.format('tom')
			His name is ###tom####
			>>> print 'His name is {:#10}'.format('tom')
			Traceback (most recent call last):
			  File "<stdin>", line 1, in <module>
			ValueError: Alternate form (#) not allowed in string format specifier
			>>> print '%08.2f'%(1.15)
			00001.15
			>>> print '%8.2f'%(1.15)
			    1.15
			>>> print '{:8.2f}'.format(1.15)
			    1.15

			说明: 指定填充字符适合必须要指明对齐方向
			

Nose:
	1. 当运行Nose时，它会自动寻找其名称以"test|Test"开头的文件，跟测试模块的名称一样，测试函数的名称也必须以test|Test开头。	
	2. 运行方式：
		1) nosetests -s <filename> 可以查看测试函数的执行过程,方便调试; 
		   nosetests -s 也可以不指定文件名,会执行当前目录下所有测试文件中的测试函数;
		   nosetests -s <测试目录> 也可以指定测试目录，会执行该目录下所有测试文件中的测试函数；
		2) nosetests -v <filename> 可以查看测试函数的执行结果; 
		   nosetests -v 也可以不指定文件名
		   nosetests -v <目录名>
		3) nosetests -s 文件名:测试函数名 用于调试某个测试文件中的某个具体测试函数，比如：
			E:\Git_test\Testing\nose>nosetests -v test_fun.py:test_fun1
			nose.test_fun.test_fun1 ... ok
			
			----------------------------------------------------------------------
			Ran 1 test in 0.002s
			
			OK
		4）nosetests -w 目录名
			E:\Git_test\Testing>nosetests -w nose
			......
			-------------------------------------
			Ran 6 tests in 0.002s
			
			OK
	
	3. setUp和tearDown
		包中的setUp在所有文件执行前执行一次；模块中的setUp在该模块执行前执行一次；类中的setUp在类中的每个测试函数执行前执行；函数的setUp在对应的该测试函数执行前执行，需要赋值或者用with_setup;

		1) 模块形式: test_module.py 代码:
			def setUp():
				print "run it before run function"
			
			def tearDown():
				print "run it after run function"
			
			def test_fun1():
				print "fun1 is running"
			
			def test_fun2():
				print "fun2 is running"
			运行结果1:
			E:\Git_test\Testing\nose>nosetests -s test_fun.py
			run it before run function
			fun1 is running
			.fun2 is running
			.run it after run function
			
			----------------------------------------------------------------------
			Ran 2 tests in 0.004s
			
			OK
			运行结果2:
			E:\Git_test\Testing\nose>nosetests -v test_fun.py
			test_fun.test_fun1 ... ok
			test_fun.test_fun2 ... ok
			
			--------------------------------------------------
			Ran 2 tests in 0.004s
			
			OK

		总结:
			 1) 模块中直接定义的setUp函数会在模块中对应所有测试函数执行之前只执行一遍,tearDown函数会在模块中对应所有测试函数执行之后只执行一遍;
			    执行过程: setUp->test_fun1->test_fun2->tearDown

		2) 类形式: test_class.py代码
			class test_person(object):
				def __init__(self):
					self.name = 'case'
					
				def setUp(self):
					print self.name + " will start"
				def tearDown(self):
					print self.name + " completed"
			
				def test_fun1(self):
					print "fun1 is running"
				def test_fun2(self):
					print "fun2 is running"
			执行结果1:
			E:\Git_test\Testing\nose>nosetests -s
			case will start
			fun1 is running
			case completed
			.case will start
			fun2 is running
			case completed
			.
			----------------------------------------------------------------------
			Ran 2 tests in 0.010s
			
			OK
			执行结果2:
			E:\Git_test\Testing\nose>nosetests -v
			test_class.test_person.test_fun1 ... ok
			test_class.test_person.test_fun2 ... ok
			
			----------------------------------------------------------------------
			Ran 2 tests in 0.005s
			
			OK
		总结: 
			1) 执行用例可以以类中的函数形式出现,类中定义的setUp函数会在类中的每个测试函数执行之前执行,tearDown函数会在类中的每个测试函数执行之后执行;
			2) ??为什么第二个测试函数执行多了.
			3) ??测试类中如何为每个测试函数初始化不同的属性值,比如不同的name,caseid;

		3) 函数形式: test_fun.py代码
			def test_fun2():
				print "fun2 is running"
			
			def test_fun1():
				print "fun1 is running"
			
			def setup_fun1():
				print "fun1 will start"
			
			def teardown_fun1():
				print "fun1 completed"
			
			def setup_fun2():
				print "fun2 will start"
			
			def teardown_fun2():
				print "fun2 completed"
			
			test_fun1.setUp=setup_fun1
			test_fun1.tearDown=teardown_fun1
			
			test_fun2.setUp=setup_fun2
			test_fun2.tearDown=teardown_fun2

			执行结果:
			E:\Git_test\Testing\nose>nosetests -s test_fun.py
			fun2 will start
			fun2 is running
			fun2 completed
			.fun1 will start
			fun1 is running
			fun1 completed
			.
			----------------------------------------------------------------------
			Ran 2 tests in 0.004s
			
			OK
		总结: 
			1) 每个测试函数执行之前都会执行对应的setUp,通过 "函数名.setUp" 赋值;每个测试函数执行之后都会执行对应的tearDown
			执行过程: setUp->fun1->tearDown->setUp->fun2->tearDown
			2) 这种情况和类中定义setUp,tearDown比较像,都会在每个测试函数之前和之后执行,不同的是类中定义的setUp,tearDown都只定义一次,定义内容都相同,而函数中setUp,tearDown可以为每个函数重新定义不同的内容,如上所示.
			3) 注意: 文件中直接通过def setUp和def tearDown定义的函数属于模块中的,这两个函数只在所以测试函数开头和结尾执行一遍,如果有需要在其中的某个测试函数前后执行,需要给该测试函数的setUp和tearDown赋值.
			4) nose还支持在每个测试函数前使用with_setup来自定义测试用例的setUp及tearDown功能，这个可以代替上面赋值方式。比如上面代码可以修改为：
				from nose.tools import with_setup
	
				def setup_fun1():
					print "fun1 will start"
				
				def teardown_fun1():
					print "fun1 completed"
				
				def setup_fun2():
					print "fun2 will start"
				
				def teardown_fun2():
					print "fun2 completed"
				
				@with_setup(setup_fun2,teardown_fun2)
				def test_fun2():
					print "fun2 is running"
				
				@with_setup(setup_fun1,teardown_fun1)
				def test_fun1():
					print "fun1 is running"
				运行结果：
				E:\Git_test\Testing\nose>nosetests -s test_fun.py
				all test file will start.................
				fun2 will start
				fun2 is running
				fun2 completed
				.fun1 will start
				fun1 is running
				fun1 completed
				.all test file already completed...............
				
				----------------------------------------------------------------------
				Ran 2 tests in 0.000s
				
				OK

		4) 包形式: __init__.py 代码
			def setUp():
				print "all test file will start................."
			
			def tearDown():
				print "all test file already completed..............."
		总结：
			1) 创建python package时会自动生成__init__.py文件，我们将setUp或tearDown写入时，
			会在所有测试模块也就是测试文件执行之前或者之后执行一次。
	
	4. 输出html报告
		1) 安装html插件：pip install nose-html-reporting
		2) 执行测试：nosetests --with-html --html-report=报告名, 例如：
		E:\Git_test\Testing\nose>nosetests -v test_fun.py --with-html --html-report=report.html
		nose.test_fun.test_fun2 ... ok
		nose.test_fun.test_fun1 ... ok
		
		----------------------------------------------------------------------
		HTML: report.html
		----------------------------------------------------------------------
		Ran 2 tests in 0.003s
		
		OK
		执行结果：会在当前目录下生成报告文件report.html
	
		

学习内容:
		１. 文件操作
		2. Atmos techrefresh code
		3. S3操作
		4. nose
		5. flake8 pep8



